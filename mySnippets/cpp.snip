snippet     basic
abbr        basic
options     head
  #include <bits/stdc++.h>
  #define range(i, a, b) for(int i = (a); i < (b); i++)
  #define rep(i, a) range(i, 0, a)
  using namespace std;

  int main() {
    return 0;
  }

snippet     basicStandard
abbr        basicStandard
options     head
  #include <bits/stdc++.h>
  #define int long long
  #define range(i, a, b) for(int i = (a); i < (b); i++)
  #define rep(i, a) range(i, 0, a)
  using namespace std;
  const int INF = sizeof(int) == sizeof(long long) ? 1e18 : 1e9;
  const int MOD = 1000000007;
  const long double EPS = 1e-8;

  signed main() {
    return 0;
  }

snippet     rep
abbr        rep
options     head
  rep (${1:i}, ${2}) {
    ${3:TARGET}
  }

snippet     range
abbr        range
options     head
  range (${1:i}, ${2}, ${3}) {
    ${4:TARGET}
  }



#####################
#                   #
#   dataStructure   #
#                   #
#####################
snippet     unionFindTree
abbr        unionFindTree
options     head
  class unionFindTree {
	private:
		vector <int> tree;
		vector <int> rank;

	public:
		unionFindTree() {}

		unionFindTree(int sz) {
			tree = vector <int> (sz);
			rank = vector <int> (sz, 0);
			for(int i = 0; i < tree.size(); i++)
				tree[i] = i;
		}

		unionFindTree(const unionFindTree &o) {
			tree = o.tree;
			rank = o.rank;
		}

		unionFindTree &operator=(const unionFindTree &o) {
			tree = o.tree;
			rank = o.rank;
			return (*this);
		};

		int root(int x) {
			return tree[x] == x ? x : tree[x] = root(tree[x]);
		}

		bool same(int a, int b) {
			return root(a) == root(b);
		}

		void unite(int a, int b) {
			a = root(a);
			b = root(b);
			if(a == b)return;

			if(rank[a] < rank[b]) swap(a, b);

			tree[b] = a;
			rank[a] += rank[a] == rank[b];
		}

		int size() {
			return tree.size();
		}
  };

#####################
#                   #
#       graph       #
#                   #
#####################
snippet     kruskal
abbr        kruskal
options     head
  class Kruskal : public unionFindTree{
  private:
    struct edge {
      int u, v, cost;
      bool operator< (const edge& e) const {
        return cost < e.cost;
      }
    };
    vector <edge> es;
    int V;

  public:
    Kruskal(int v, int e) : unionFindTree(v){
      V = v;
      es = vector <edge> (e);
    }

    void addEdge(int start, int end, int cost) {
      es.push_back({start, end, cost});
    }

    int execute() {
      sort(es.begin(), es.end());
      int res = 0;
      for(int i = 0; i < es.size(); i++) {
        edge e = es[i];
        if(!same(e.u, e.v)) {
          unite(e.u, e.v);
          res += e.cost;
        }
      }
      return res;
    }
  };

snippet     dijkstra
abbr        dijkstra
options     head
  class Dijkstra {
  private:
    struct edge {int to, cost;};
    vector <vector <edge>> G;
    vector <int> d;
    priority_queue <pair <int, int>, vector <pair <int, int>>, greater <pair <int, int>>> que;

  public:
    Dijkstra(int v) {
      G = vector <vector <edge>> (v);
      d = vector <int> (v);
    }

    void addEdge(int start, int end, int cost) {
      G[start].push_back({end, cost});
    }

    int dist(int n) {
      return d[n];
    }

    void execute(int start) {
      for (int i = 0; i < G.size(); i++)
        d[i] = i == start ? 0 : INF;
      que.push({0 , start});
      while(!que.empty()) {
        pair <int, int> p = que.top(); que.pop();
        int from = p.second;
        if(d[from] < p.first)continue;
        for(int i = 0; i < G[from].size(); i++) {
          edge e = G[from][i];
          if(d[e.to] > d[from] + e.cost) {
            d[e.to] = d[from] + e.cost;
            que.push({d[e.to], e.to});
          }
        }
      }
    }
  };

snippet     warshall
abbr        warshall
options     head
  class Warshall {
  private:
    vector <vector <int>> G;

  public:
    Warshall(int v) {
      G = vector <vector <int>> (v, vector <int> (v));
      for(int i = 0; i < G.size(); i++)
        for(int j = 0; j < G.size(); j++)
          G[i][j] = i == j ? 0 : INF;
    }

    void addEdge(int start, int end, int cost) {
      G[start][end] = cost;
    }

    int dist(int start, int end) {
      return G[start][end];
    }

    bool checkNegativeCircle() {
      bool flag = false;
      for (int i = 0; i < G.size(); i++)
        if(G[i][i] < 0)
          flag = true;
      return flag;
    }

    void execute() {
      for(int k = 0; k < G.size(); k++)
        for(int i = 0; i < G.size(); i++)
          for(int j = 0; j < G.size(); j++)
            if(G[i][k] != INF && G[k][j] != INF)
              G[i][j] = min(G[i][j], G[i][k] + G[k][j]);
    }

  };

######################
#                    #
#        Math        #
#                    #
######################
snippet     eratosthenes
abbr        eratosthenes
options     head
  vector <bool> eratosthenes(int n) {
    vector <bool> prime(n + 1, true);
      prime = vector <bool> (n + 1, true);
      if(n >= 0) prime[0] = false;
      if(n >= 1) prime[1] = false;
      for(int i = 2; i * i <= n; i++)
        if(prime[i])
          for(int j = i * 2; j < n; j += i)
            prime[j] = false;
  }

snippet     factorial
abbr        factorial
options     head
  long long int factorial(int n) {
    long long int ans = 1;
    while(n--)
      ans = (ans * n) % MOD;
    return ans;
  }

snippet     gcd
abbr        gcd
options     head
  int gcd(int a, int b) {
    return (b == 0 ? a : gcd(b, a % b));
  }

snippet     isPrime
abbr        isPrime
options     head
  bool isPrime(int n) {
    for(int i = 2; i * i <= n; i++) if(!(n % i)) return false;
    return n == 1 ? false : true;
  }

snippet     lcm
abbr        lcm
options     head
  int gcd(int a, int b) {
    return (b == 0 ? a : gcd(b, a % b));
  }

  int lcm(int a, int b) {
    return a * b / gcd(a, b);
  }

snippet     powMod
abbr        powMod
options     head
  long long int powMod(long long int n, long long int p) {
    if(p == 0)
      return 1;
    else if(p % 2 == 0)
      return (powMod(n, p / 2) * powMod(n, p / 2)) % MOD;
    else if(p % 2 == 1)
      return (powMod(n, p - 1) * n) % MOD;
  }

#####################
#                   #
#       Other       #
#                   #
#####################
snippet     binarySerch
abbr        binarySerch
options     head
  template <class T>
  bool c(T mid) {

  }

  template <class T>
  T execute(T low, T high) {
    for(int i = 0; i < 100; i++) {
     T mid = (high + low) / 2;
     (c(mid) ? low : high) = mid;
    }
    return low;
  }
